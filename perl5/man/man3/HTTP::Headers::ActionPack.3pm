.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "HTTP::Headers::ActionPack 3"
.TH HTTP::Headers::ActionPack 3 "2013-06-18" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers::ActionPack \- HTTP Action, Adventure and Excitement
.SH "VERSION"
.IX Header "VERSION"
version 0.09
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use HTTP::Headers::ActionPack;
\&
\&  my $pack       = HTTP::Headers::ActionPack\->new;
\&  my $media_type = $pack\->create_header( \*(AqContent\-Type\*(Aq => \*(Aqapplication/xml;charset=UTF\-8\*(Aq );
\&  my $link       = $pack\->create( \*(AqLinkHeader\*(Aq => [ \*(Aq</test/tree>\*(Aq, rel => "up" ] );
\&
\&  # auto\-magic header inflation
\&  # for multiple types
\&  $pack\->inflate( $http_headers_instance );
\&  $pack\->inflate( $http_request_instance );
\&  $pack\->inflate( $plack_request_instance );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a module to handle the inflation and deflation of
complex \s-1HTTP\s0 header types. In many cases header values are
simple strings, but in some cases they are complex values
with a lot of information encoded in them. The goal of this
module is to make the parsing and analysis of these headers
as easy as calling \f(CW\*(C`inflate\*(C'\fR on a compatible object (see
below for a list).
.PP
This top-level class is basically a Factory for creating
instances of the other classes in this module. It contains
a number of convenience methods to help make common cases
easy to write.
.SH "DEFAULT MAPPINGS"
.IX Header "DEFAULT MAPPINGS"
This class provides a set of default mappings between \s-1HTTP\s0
headers and the classes which can inflate them. Here is the
list of default mappings this class provides.
.PP
.Vb 10
\&  Link                HTTP::Headers::ActionPack::LinkList
\&  Content\-Type        HTTP::Headers::ActionPack::MediaType
\&  Accept              HTTP::Headers::ActionPack::MediaTypeList
\&  Accept\-Charset      HTTP::Headers::ActionPack::PriorityList
\&  Accept\-Encoding     HTTP::Headers::ActionPack::PriorityList
\&  Accept\-Language     HTTP::Headers::ActionPack::PriorityList
\&  Date                HTTP::Headers::ActionPack::DateHeader
\&  Client\-Date         HTTP::Headers::ActionPack::DateHeader
\&  Expires             HTTP::Headers::ActionPack::DateHeader
\&  Last\-Modified       HTTP::Headers::ActionPack::DateHeader
\&  If\-Unmodified\-Since HTTP::Headers::ActionPack::DateHeader
\&  If\-Modified\-Since   HTTP::Headers::ActionPack::DateHeader
\&  WWW\-Authenticate    HTTP::Headers::ActionPack::WWWAuthenticate
\&  Authentication\-Info HTTP::Headers::ActionPack::AuthenticationInfo
\&  Authorization       HTTP::Headers::ActionPack::Authorization
.Ve
.PP
\&\s-1NOTE:\s0 The 'Client\-Date' header is often added by \s-1LWP\s0 on
HTTP::Response objects.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP """new( ?%mappings )""" 4
.el .IP "\f(CWnew( ?%mappings )\fR" 4
.IX Item "new( ?%mappings )"
The constructor takes an option hash of header-name to class
mappings to add too (or override) the default mappings (see
above for details). Each class is expected to have a
\&\f(CW\*(C`new_from_string\*(C'\fR method which can parse the string
representation of the given header and return an object.
.ie n .IP """mapping""" 4
.el .IP "\f(CWmapping\fR" 4
.IX Item "mapping"
This returns the set of mappings in this instance.
.ie n .IP """classes""" 4
.el .IP "\f(CWclasses\fR" 4
.IX Item "classes"
This returns the list of supported classes, which is by default
the list of classes included in this modules, but it also
will grab any additionally classes that were specified in the
\&\f(CW%mappings\fR parameter to \f(CW\*(C`new\*(C'\fR (see above).
.ie n .IP """get_content_negotiator""" 4
.el .IP "\f(CWget_content_negotiator\fR" 4
.IX Item "get_content_negotiator"
Returns an instance of HTTP::Headers::ActionPack::ContentNegotiation.
.ie n .IP """create( $class_name, $args )""" 4
.el .IP "\f(CWcreate( $class_name, $args )\fR" 4
.IX Item "create( $class_name, $args )"
This method, given a \f(CW$class_name\fR and \f(CW$args\fR, will inflate
the value using the class found in the \f(CW\*(C`classes\*(C'\fR list. If
\&\f(CW$args\fR is a string it will call \f(CW\*(C`new_from_string\*(C'\fR on
the \f(CW$class_name\fR, but if \f(CW$args\fR is an \s-1ARRAY\s0 ref, it
will dereference the \s-1ARRAY\s0 and pass it to \f(CW\*(C`new\*(C'\fR.
.ie n .IP """create_header( $header_name, $header_value )""" 4
.el .IP "\f(CWcreate_header( $header_name, $header_value )\fR" 4
.IX Item "create_header( $header_name, $header_value )"
This method, given a \f(CW$header_name\fR and a \f(CW$header_value\fR will
inflate the value using the class found in the mappings. If
\&\f(CW$header_value\fR is a string it will call \f(CW\*(C`new_from_string\*(C'\fR on
the class mapped to the \f(CW$header_name\fR, but if \f(CW$header_value\fR
is an \s-1ARRAY\s0 ref, it will dereference the \s-1ARRAY\s0 and pass it to
\&\f(CW\*(C`new\*(C'\fR.
.ie n .IP """inflate( $http_headers )""" 4
.el .IP "\f(CWinflate( $http_headers )\fR" 4
.IX Item "inflate( $http_headers )"
.PD 0
.ie n .IP """inflate( $http_request )""" 4
.el .IP "\f(CWinflate( $http_request )\fR" 4
.IX Item "inflate( $http_request )"
.ie n .IP """inflate( $plack_request )""" 4
.el .IP "\f(CWinflate( $plack_request )\fR" 4
.IX Item "inflate( $plack_request )"
.ie n .IP """inflate( $web_request )""" 4
.el .IP "\f(CWinflate( $web_request )\fR" 4
.IX Item "inflate( $web_request )"
.PD
Given either a HTTP::Headers instance, a HTTP::Request
instance, a Plack::Request instance, or a Web::Request
instance, this method will inflate all the relevant headers
and store the object in the same instance.
.Sp
In theory this should not negatively affect anything since all
the header objects overload the stringification operator, and
most often the headers are treated as strings. However, this
is not for certain and care should be taken.
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "Plack Compatibility"
.IX Subsection "Plack Compatibility"
We have a test in the suite that checks to make sure that
any inflated header objects will pass between HTTP::Request
and HTTP::Response objects as well as Plack::Request
and Plack::Response objects.
.PP
A simple survey of most of the Plack::Handler subclasses
shows that most of them will end up properly stringifying
these header objects before sending them out. The notable
exceptions were the Apache handlers.
.PP
At the time of this writing, the solution for this would be
for you to either stringify these objects prior to returning
your Plack::Response, or to write a simple middleware component
that would do that for you. In future versions we might provide
just such a middleware (it would likely inflate the header objects
on the request side as well).
.SS "Stringification"
.IX Subsection "Stringification"
As mentioned above, all the header objects overload the
stringification operator, so normal usage of them should just
do what you would expect (stringify in a sensible way). However
this is not certain and so care should be taken when passing
object headers onto another library that is expecting strings.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Andrew Nelson <anelson@cpan.org>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
Karen Etheridge <ether@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
