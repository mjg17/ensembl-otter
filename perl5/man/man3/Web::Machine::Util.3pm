.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Web::Machine::Util 3"
.TH Web::Machine::Util 3 "2015-07-05" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Web::Machine::Util \- General Utility module
.SH "VERSION"
.IX Header "VERSION"
version 0.16
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Web::Machine::Util;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is just a basic utility module used internally by
Web::Machine. There are no real user serviceable parts
in here.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """first""" 4
.el .IP "\f(CWfirst\fR" 4
.IX Item "first"
This is imported from List::Util and passed on here
for export.
.ie n .IP """pair_key""" 4
.el .IP "\f(CWpair_key\fR" 4
.IX Item "pair_key"
.PD 0
.ie n .IP """pair_value""" 4
.el .IP "\f(CWpair_value\fR" 4
.IX Item "pair_value"
.PD
These two functions are used for fetching the key
and value out of a pair in the Web::Machine internals.
We represent a pair simply as a \s-1HASH\s0 ref with one key.
.ie n .IP """inflate_headers( $request )""" 4
.el .IP "\f(CWinflate_headers( $request )\fR" 4
.IX Item "inflate_headers( $request )"
This will call \f(CW\*(C`inflate\*(C'\fR on an instance of HTTP::Headers::ActionPack.
.ie n .IP """create_header( @args )""" 4
.el .IP "\f(CWcreate_header( @args )\fR" 4
.IX Item "create_header( @args )"
This will call \f(CW\*(C`create\*(C'\fR on an instance of HTTP::Headers::ActionPack.
.ie n .IP """create_date( $date_string | $time_peice )""" 4
.el .IP "\f(CWcreate_date( $date_string | $time_peice )\fR" 4
.IX Item "create_date( $date_string | $time_peice )"
Given either a \f(CW$date_string\fR or an instance of Time::Piece,
this will inflate it into a HTTP::Headers::ActionPack::DateHeader
object, suitable for use in the \s-1FSM.\s0
.ie n .IP """bind_path( $path_spec, $path )""" 4
.el .IP "\f(CWbind_path( $path_spec, $path )\fR" 4
.IX Item "bind_path( $path_spec, $path )"
Given a \f(CW$path_spec\fR (described below) and a \f(CW$path\fR, this will
either bind the path to the spec and return and array of bound
values, or it will return nothing. Returning nothing indicates
that no match was found. Additionally, if this function is called
in scalar context, and there is only one match, it will return
that item. Otherwise it will return the array as normal. This all
makes it easy to use the following idiom:
.Sp
.Vb 6
\&  if ( my $id = bind_path( \*(Aq/:id\*(Aq, $request\->path_info ) ) {
\&      # handle the case with an ID here
\&  }
\&  else {
\&      # handle other cases here
\&  }
.Ve
.Sp
The \f(CW$path_spec\fR follows a pretty standard convention. Literal
path parts must match corresponding literal. Variable path parts
are prefixed by a colon and are captured for returning later, if
a question mark (?) prefixes the colon, that element will be
considered optional. And lastly the \*(L"splat\*(R" operator (\f(CW\*(C`*\*(C'\fR) is
supported and causes all the rest of the path segments to be
returned. Below are a few examples of this:
.Sp
.Vb 8
\&  spec                  path             result
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  /test/:foo/:bar       /test/1/2        ( 1, 2 )
\&  /test/:foo/:bar       /test/1/         undef #failure\-case
\&  /test/*               /test/1/2/3      ( 1, 2, 3 )
\&  /user/:id/:action     /user/1/edit     ( 1, \*(Aqedit\*(Aq )
\&  /?:id                 /201             ( 201 )
\&  /?:id                 /                ( )
.Ve
.Sp
This function is kept deliberately simple and it is expected
that the user will use \f(CW\*(C`my\*(C'\fR in the array form to assign
multiple variables, like this:
.Sp
.Vb 1
\&  my ( $foo, $bar ) = bind_path( \*(Aq/test/:foo/:bar\*(Aq, $path );
.Ve
.Sp
In the future we might add a \f(CW\*(C`bind_path_hash\*(C'\fR function which
captures the variable names as well, but to be honest, if you
feel you need that, you likely want one of the many excellent
path dispatching modules available on \s-1CPAN.\s0
.Sp
\&\fB\s-1NOTE:\s0\fR Some care should be taken when using path specs in
which the only things are either optional parameters
(prefixed with \f(CW\*(C`?:\*(C'\fR) or the \*(L"splat\*(R" operator (\f(CW\*(C`*\*(C'\fR)
as they can return empty arrays, which in certain
contexts can look like match failure. In these cases you
can test the match in scalar context to verify, a match
failure will be \f(CW\*(C`undef\*(C'\fR whereas a match success (in
which nothing was matched) will return \f(CW0\fR (indicating
an array with zero size).
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Stevan Little <stevan@cpan.org>
.IP "\(bu" 4
Dave Rolsky <autarch@urth.org>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 4
Andreas Marienborg <andreas.marienborg@gmail.com>
.IP "\(bu" 4
Andrew Nelson <anelson@cpan.org>
.IP "\(bu" 4
Arthur Axel 'fREW' Schmidt <frioux@gmail.com>
.IP "\(bu" 4
Carlos Fernando Avila Gratz <cafe@q1software.com>
.IP "\(bu" 4
Fayland Lam <fayland@gmail.com>
.IP "\(bu" 4
George Hartzell <hartzell@alerce.com>
.IP "\(bu" 4
Gregory Oschwald <goschwald@maxmind.com>
.IP "\(bu" 4
Jesse Luehrs <doy@tozt.net>
.IP "\(bu" 4
John \s-1SJ\s0 Anderson <genehack@genehack.org>
.IP "\(bu" 4
Mike Raynham <enquiries@mikeraynham.co.uk>
.IP "\(bu" 4
Mike Raynham <mike.raynham@spareroom.co.uk>
.IP "\(bu" 4
Nathan Cutler <ncutler@suse.cz>
.IP "\(bu" 4
Olaf Alders <olaf@wundersolutions.com>
.IP "\(bu" 4
Thomas Sibley <tsibley@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Infinity Interactive, Inc..
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
