.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Web::Simple::AntiquatedPerl 3"
.TH Web::Simple::AntiquatedPerl 3 "2012-05-07" "perl v5.12.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Web::Simple::AntiquatedPerl \- the slides from the talk
.SH "WHAT?"
.IX Header "WHAT?"
Web::Simple was originally introduced in a talk at the Italian Perl Workshop,
entitled Antiquated Perl.
.PP
The video is available on the Shadowcat site: <http://www.shadowcat.co.uk/archive/conference\-video/ipw\-2009/antiquated>
.PP
If you don't particularly want to watch me confusing a bunch of Italian perl
mongers, the slides are reproduced below.
.SH "SLIDES"
.IX Header "SLIDES"
.Vb 10
\&  Antiquated
\&  Perl
\&  \-\-\-\-
\&  Modern
\&  Perl?
\&  \-\-\-\-
\&  Post
\&  Modern
\&  Perl
\&  \-\-\-\-
\&  Enlightened
\&  Perl
\&  \-\-\-\-
\&  everybody
\&  knows
\&  \-\-\-\-
\&  Catalyst
\&  Moose
\&  DBIx::Class
\&  \-\-\-\-
\&  Modern
\&  Perl?
\&  \-\-\-\-
\&  perl5
\&  v10
\&  \-\-\-\-
\&    given ($x) {
\&      when (3) {
\&    ...
\&  \-\-\-\-
\&  ~~
\&  \-\-\-\-
\&  what\*(Aqs the
\&  opposite?
\&  \-\-\-\-
\&  Old
\&  Perl?
\&  \-\-\-\-
\&  if it 
\&  works
\&  \-\-\-\-
\&  Legacy
\&  Perl?
\&  \-\-\-\-
\&  not
\&  interesting
\&  \-\-\-\-
\&  Stupid
\&  Perl
\&  \-\-\-\-
\&  *$&^*(^
\&  FormMail.PL
\&  \-\-\-\-
\&  Antiquated
\&  Perl
\&  \-\-\-\-
\&  Antique
\&  \-\-\-\-
\&  Old *and*
\&  beautiful
\&  \-\-\-\-
\&  Simple
\&  Elegant
\&  \-\-\-\-
\&    $|++
\&  \-\-\-\-
\&    use IO::Handle;
\&    STDOUT\->autoflush(1);
\&  \-\-\-\-
\&  it\*(Aqs core.
\&  it\*(Aqs fine.
\&  \-\-\-\-
\&  but why
\&  think?
\&  \-\-\-\-
\&    select((select(FOO),$|++)[0])
\&  \-\-\-\-
\&    (select(FOO),$|++)
\&    \->
\&    ($old_selected_fh,$|)
\&  \-\-\-\-
\&    (select(FOO),$|++)[0]
\&    \->
\&    $old_select_fh
\&  \-\-\-\-
\&    select((select(FOO),$|++)[0])
\&    \->
\&    use IO::Handle;
\&    FOO\->autoflush(1)
\&  \-\-\-\-
\&  ~~
\&  \-\-\-\-
\&    ~~@x
\&  \-\-\-\-
\&    ~(~(@x))
\&  \-\-\-\-
\&  bitwise
\&  negation
\&  \-\-\-\-
\&  so ...
\&  \-\-\-\-
\&    ~@x
\&    \->
\&    ~(scalar @x)
\&  \-\-\-\-
\&    ~~$number
\&    \->
\&    $number
\&  \-\-\-\-
\&    ~~@x
\&    \->
\&    scalar @x
\&  \-\-\-\-
\&    perl \-MMoose \-e\*(Aqprint ~~keys %INC\*(Aq
\&    84
\&  \-\-\-\-
\&  overload::constant
\&  \-\-\-\-
\&  lets you
\&  affect
\&  parsing
\&  \-\-\-\-
\&  numbers
\&  strings
\&  \-\-\-\-
\&  q qq qr
\&  t s qw
\&  \-\-\-\-
\&  i18n.pm
\&  \-\-\-\-
\&  ~~"$foo bar"
\&  loc("_[0] bar", $foo)
\&  \-\-\-\-
\&  for
\&  \-\-\-\-
\&    for ($foo) {
\&      /bar/ and ...
\&  \-\-\-\-
\&    for ($foo) {
\&      /bar/ and return do {
\&        <code here>
\&      }
\&  \-\-\-\-
\&    /foo/gc
\&  \-\-\-\-
\&    /\eGbar/gc
\&  \-\-\-\-
\&    sub parse {
\&      my ($self, $str) = @_;
\&      for ($str) {
\&        /match1/gc and return
\&          $self\->_subparse_1($_)
\&  \-\-\-\-
\&    sub _subparse_1 {
\&      my ($self) = @_;
\&      for ($_[1]) {
\&        /\eGsubmatch1/gc ...
\&  \-\-\-\-
\&  prototypes
\&  \-\-\-\-
\&    sub foo (&) {
\&  \-\-\-\-
\&    foo {
\&      ...
\&    };
\&  \-\-\-\-
\&    prototype \e&foo
\&  \-\-\-\-
\&  typeglobs
\&  \-\-\-\-
\&    *{"${package}::${name}"}
\&      = sub { ... }
\&  \-\-\-\- 
\&    local
\&  \-\-\-\-
\&    local $_
\&  \-\-\-\-
\&    local *Carp::croak
\&      = \e&Carp::confess;
\&  \-\-\-\-
\&    do {
\&      local (@ARGV, $/) = $file;
\&      <>
\&    }
\&  \-\-\-\-
\&  strict
\&  and
\&  warnings
\&  \-\-\-\-
\&    strict\->import
\&  \-\-\-\-
\&  affects
\&  compilation
\&  scope
\&  \-\-\-\-
\&    sub strict_and_warnings::import {
\&      strict\->import;
\&      warnings\->import;
\&    }
\&  \-\-\-\-
\&    use strict_and_warnings;
\&  \-\-\-\-
\&  $^H
\&  %^H
\&  \-\-\-\-
\&    $^H |= 0x20000;
\&    $^H{\*(Aqfoo\*(Aq}
\&      = bless($foo, \*(AqMy::Foo\*(Aq);
\&  \-\-\-\-
\&    sub My::Foo::DESTROY {
\&  \-\-\-\-
\&    delete ${$package}{myimport}
\&  \-\-\-\-
\&  B::Hooks::EndOfScope
\&  \-\-\-\-
\&  tie
\&  \-\-\-\-
\&    tie $var, \*(AqFoo\*(Aq;
\&  \-\-\-\-
\&    sub FETCH
\&    sub STORE
\&  \-\-\-\-
\&  Scalar
\&  Array
\&  Hash
\&  Handle
\&  \-\-\-\-
\&  now ...
\&  \-\-\-\-
\&  mst: destruction
\&  testing technology
\&  since March 1983
\&  \-\-\-\-
\&  3 days
\&  old
\&  \-\-\-\-
\&  2 weeks
\&  early
\&  \-\-\-\-
\&  incubator
\&  \-\-\-\-
\&  glass box
\&  plastic tray
\&  heater
\&  \-\-\-\-
\&  design
\&  flaw
\&  \-\-\-\-
\&  BANG
\&  \-\-\-\-
\&  so ...
\&  \-\-\-\-
\&  interesting
\&  fact
\&  \-\-\-\-
\&  prototypes
\&  only warn
\&  when parsed
\&  \-\-\-\-
\&  error when
\&  compiled
\&  \-\-\-\-
\&  so ...
\&  \-\-\-\-
\&    dispatch [
\&      sub (GET + /) { ... },
\&      sub (GET + /user/*) { ... }
\&    ];
\&  \-\-\-\-
\&    foreach my $sub (@$dispatch) {
\&      my $proto = prototype $sub;
\&      $parser\->parse($proto);
\&      ...
\&  \-\-\-\-
\&    PARSE: { do {
\&      push @match, $self\->_parse_spec_section($spec)
\&        or $self\->_blam("Unable to work out what the next section is");
\&      last PARSE if (pos == length);
\&      /\eG\e+/gc or $self\->_blam(\*(AqSpec sections must be separated by +\*(Aq);
\&    } until (pos == length) };
\&  \-\-\-\-
\&    sub _blam {
\&      my ($self, $error) = @_;
\&      my $hat = (\*(Aq \*(Aq x pos).\*(Aq^\*(Aq;
\&      die "Error parsing dispatch specification: ${error}\en
\&    ${_}
\&    ${hat} here\en";
\&    }
\&  \-\-\-\-
\&    Error parsing ...
\&    GET+/foo
\&       ^ here
\&  \-\-\-\-
\&    sub (GET + /user/*) {
\&     my ($self, $user) = @_;
\&  \-\-\-\-
\&  I hate
\&  fetching
\&  $self
\&  \-\-\-\-
\&    *{"${app}::self"}
\&      = \e${"${app}::self"};
\&  \-\-\-\-
\&  use vars
\&  \-\-\-\-
\&    sub _run_with_self {
\&      my ($self, $run, @args) = @_;
\&      my $class = ref($self);
\&      no strict \*(Aqrefs\*(Aq;
\&      local *{"${class}::self"} = \e$self;
\&      $self\->$run(@args);
\&    }
\&  \-\-\-\-
\&  HTML
\&  output
\&  \-\-\-\-
\&  templates
\&  \-\-\-\-
\&  HTML is
\&  NOT TEXT
\&  \-\-\-\-
\&    <div>,
\&      $text,
\&    </div>;
\&  \-\-\-\-
\&  <div>
\&  \-\-\-\-
\&  <$fh>
\&  \-\-\-\-
\&    tie *{"${app}::${name}"},
\&      \*(AqXML::Tags::TIEHANDLE\*(Aq,
\&      "<${name}>";
\&  \-\-\-\-
\&    sub TIEHANDLE { my $str = $_[1]; bless \e$str, $_[0] }
\&    sub READLINE { ${$_[0]} }
\&  \-\-\-\-
\&    sub DESTROY {
\&      my ($into, @names) = @$_[0];
\&      no strict \*(Aqrefs\*(Aq;
\&      delete ${$into}{$_}
\&        for @names;
\&    }
\&  \-\-\-\-
\&  </div>
\&  \-\-\-\-
\&  glob(\*(Aq/div\*(Aq);
\&  \-\-\-\-
\&    *CORE::GLOBAL::glob
\&      = sub { ... };
\&  \-\-\-\-
\&    delete
\&      ${CORE::GLOBAL::}{glob};
\&  \-\-\-\-
\&    sub foo {
\&      use XML::Tags qw(div);
\&      <div>, "foo!", </div>;
\&    }
\&  \-\-\-\-
\&  what about
\&  interpolation
\&  \-\-\-\-
\&    my $stuff = \*(Aqfoo"bar\*(Aq;
\&    <a href="$stuff">
\&  \-\-\-\-
\&  hmm ...
\&  \-\-\-\-
\&  overload::constant!
\&  \-\-\-\-
\&    glob(\*(Aqa href="\*(Aq.$stuff.\*(Aq"\*(Aq);
\&  \-\-\-\-
\&    glob(
\&      bless(\e\*(Aqa href="\*(Aq, \*(AqMagicTag\*(Aq)
\&      .$stuff
\&      .bless(\e\*(Aq"\*(Aq, \*(AqMagicTag\*(Aq)
\&    )
\&  \-\-\-\-
\&    use overload
\&      \*(Aq.\*(Aq => \*(Aqconcat\*(Aq;
\&  
\&    sub concat {
\&  \-\-\-\-
\&  hooking
\&  it up
\&  \-\-\-\-
\&    sub (.html) {
\&      filter_response {
\&        $self\->render_html($_[1])
\&      }
\&    }
\&  \-\-\-\-
\&    bless(
\&      $_[1],
\&      \*(AqWeb::Simple::ResponseFilter\*(Aq
\&    );
\&  \-\-\-\-
\&    if ($self\->_is_response_filter($result)) {
\&      return $self\->_run_with_self(
\&        $result,
\&        $self\->_run_dispatch_for($new_env, \e@disp)
\&      );
\&    }
\&  \-\-\-\-
\&  and the result?
\&  \-\-\-\-
\&   goto &demo;
\&  \-\-\-\-
\&  questions?
\&  \-\-\-\-
\&  thank
\&  you
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Matt S. Trout <mst@shadowcat.co.uk>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2011 Matt S. Trout <mst@shadowcat.co.uk>
.SH "LICENSE"
.IX Header "LICENSE"
This text is free documentation under the same license as perl itself.
