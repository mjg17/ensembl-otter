#!/usr/bin/env perl

use strict;
use warnings;

use feature 'switch';


package Bio::Otter::Plack::Info;

use JSON::XS;

use Moo;
extends 'Web::Machine::Resource';

has protocol => ( is => 'rw' );

sub init {
    my ($self, $args) = @_;
    $self->protocol($args->{protocol});
    return;
};

sub content_types_provided {
    return
        [
         { 'application/json' => 'to_json' },
        ];
}

sub _fetch_info {
    my ($self) = @_;

    my $result;
    $self->protocol->send_command('info', undef, undef, sub { ($result) = @_ });

    # YUK - dup with Zircon::ZMap handlers.
    my %tag_attribs;
    $tag_attribs{$_->[0]} = $_->[1] for @{$result->reply}; # [ tag => attribs, content ]

    return {
        info => $tag_attribs{info},
    };
}

sub to_json {
    my ($self) = @_;
    my $info = $self->_fetch_info;
    return encode_json($info);
}


package Bio::Otter::Plack::Main;

# use Module::Runtime qw( require_module );
use Web::Machine;
use Web::Simple;

has protocol => ( is => 'rw' );

sub _make_wm {
    my ($resource, $resource_args) = @_;
    my $machine = Web::Machine->new(
        resource      => $resource,
        resource_args => $resource_args,
        );
    return $machine;
}

sub dispatch_request {
    my ($self) = @_;
    return (
        sub (GET + /info) { _make_wm('Bio::Otter::Plack::Info', [ protocol => $self->protocol ]); },
        );
}


package Bio::Otter::GetScript::WebServer;

use AnyEvent::Impl::Perl;       # (try to) ensure pure-perl loop is used
use AnyEvent;
use Twiggy::Server;

use Zircon::Context::ZMQ::AnyEvent;
use Zircon::Protocol;

use base qw(
    Bio::Otter::Utils::GetScript
    Zircon::Protocol::Server
);

sub version { return 'web_server 0.1'; };
sub log_filename { return 'web_server.txt'; }

# GetScript objects are singletons, hence these class members are simple variables.
my $_app;
my $_server;
my $_protocol;

sub do_it {
    my ($self) = @_;

    $self->do_requires;

    $self->log_message('starting web server');
    $self->_setup_web_server;

    $self->log_message('starting zircon');
    $self->_setup_zircon;

    $self->log_message(sprintf('app isa %s', ref $_app));
    $_app->protocol($_protocol);

    AnyEvent::Impl::Perl::loop;

    return;
}

sub _setup_web_server {
    my ($self) = @_;

    my $web_port = $self->require_arg('web_port');
    my $app = $self->_setup_app;

    $_server = Twiggy::Server->new(
        host => '127.0.0.1',
        port => $web_port,
    );
    $_server->register_service($app->to_psgi_app);

    $_app = $app;

    return;
}

sub _setup_app {
    my ($self) = @_;
    my $app = Bio::Otter::Plack::Main->new();
    return $app;
}

sub _setup_zircon {
    my ($self) = @_;

    my $peer_socket = $self->require_arg('peer_socket');

    my $context = Zircon::Context::ZMQ::AnyEvent->new(-trace_prefix => 'WSP');
    $_protocol   = Zircon::Protocol->new(
        -app_id     => 'web_server',
        -app_tag    => 'otter_web',
        -serialiser => 'JSON',
        -context    => $context,
        -server     => $self,
        );

    $_protocol->send_handshake(
        $peer_socket,
        sub {
            my ($result) = @_;
            $self->log_message(sprintf 'handshake: %s', _zircon_message($result));
        },
        );

    return;
}

# FIXME: code dup with zircon/utterloss/bin/zapmop
#
sub _zircon_message {
    my ($result) = @_;
    for ($result) {
        when ($_->isa('Zircon::Protocol::Result::Reply')) {
            return $result->success ? 'succeeded' : 'failed';
        }
        when ($_->isa('Zircon::Protocol::Result::Timeout')) {
            return 'timeout';
        }
        when (ref) {
            return sprintf 'unknown result: class: %s', ref;
        }
    }
    return 'unknown result';
}

sub zircon_server_protocol_command {
    my ($self, $command, $view_id, $request_body) = @_;

    # FIXME: some dup with Zircon::Protocol::Server::AppLauncher (and below, in process())
    my $tag_entity_hash = { };
    $tag_entity_hash->{$_->[0]} = $_ for @{$request_body};

    for ($command) {

        when ('ping') {
            return $_protocol->message_ok('pong');
        }

        default {
            my $reason = "Unknown web_server zircon command: '${command}'";
            return $_protocol->message_command_unknown($reason);
        }
    }
    return;
}

sub log_context {
    return 'web_server';
}

sub DESTROY {
    my ($self) = @_;
    $self->log_message(      'DESTROY()');
    $self->zircon_server_log('DESTROY()');

    $_protocol = undef;
    $_server   = undef;
    $_app      = undef;

    return;
}

## no critic (Modules::ProhibitMultiplePackages)

package main;

use Log::Log4perl::Level;

Bio::Otter::GetScript::WebServer
    ->new(log4perl => $DEBUG)
    ->run;

exit;

__END__

=head1 AUTHOR

Ana Code B<email> anacode@sanger.ac.uk
